---
title: "automatization_notebook"
output: word_document
date: "`r Sys.Date()`"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)

```

# Чтение данных

В вашем варианте нужно использовать датасеты cardio_train_big или cardio_train_not_too_big.

```{r, message=FALSE}
df <- read_csv2("./data/raw/cardio_train_big.csv")
df %>% head()
```

# Выведите общее описание данных

```{r}
df %>% glimpse()
```

# Очистка данных

1) Уберите переменные, в которых пропущенных значений больше 20% или уберите субъектов со слишком большим количеством пропущенных значений. Или совместите оба варианта. Напишите обоснование, почему вы выбрали тот или иной вариант:
```{r}
df %>% sapply(function(x) sum(is.na(x)))
```

**Обоснование**: В датасете отсутствуют пропущенные значения.


2) Переименуйте переменные в человекочитаемый вид (что делать с пробелами в названиях?);

3) В соответствии с описанием данных приведите переменные к нужному типу (numeric или factor);

4) Отсортируйте данные по возрасту по убыванию;

5) Сохраните в файл outliers.csv субъектов, которые являются выбросами (например, по правилу трёх сигм) — это необязательное задание со звёздочкой;

6) Присвойте получившийся датасет переменной "cleaned_data".


```{r}
df <- df %>%
  rename('Arterial Pressure High' = ap_hi,
         'Arterial Pressure Low' = ap_lo,
         'glucose' = gluc,
         'alcohol' = alco) %>% 
  mutate(id = as.factor(id),
         gender = as.factor(gender),
         cholesterol = as.factor(cholesterol),
         glucose = as.factor(glucose),
         smoke = as.factor(smoke),
         alcohol = as.factor(alcohol),
         active = as.factor(active),
         cardio = as.factor(cardio)) %>% 
  arrange(desc(age))
df %>% summary()
```
tibble позволяет пробелы в названиях (хотя я не уверен, что новые названия - хорошая идея, потому что прежние названия были вполне приемлемые). 
Наблюдаются явные выбросы в height, weight, Arterial Pressure High, Arterial Pressure Low. 
```{r}
df %>% glimpse()
```
Фильтровать решил по интерквартильному размаху.
```{r}
find_outliers <- function(x) {
  q1 <- quantile(x, 0.25)
  q3 <- quantile(x, 0.75)
  iqr <- q3 - q1
  lower_bound <- q1 - 1.5 * iqr
  upper_bound <- q3 + 1.5 * iqr
  outliers <- x < lower_bound | x > upper_bound
  return(outliers)
}
outliers <- df %>%
  filter_if(is.numeric, any_vars(find_outliers(.))) %>% 
  write_csv2(file = "./data/output/outliers.csv")
```


Данные после вычитания выбросов записаны в cleaned_data.
```{r}
cleaned_data <- df %>%
  anti_join(outliers, by = "id") 
cleaned_data %>% summary()
```


# Сколько осталось переменных?

```{r}
cleaned_data %>% ncol()
```

# Сколько осталось случаев?

```{r}
cleaned_data %>% nrow()
```

# Есть ли в данных идентичные строки?

```{r}
cleaned_data %>% 
  duplicated() %>% 
  sum()
```
Идентичные строки отсутствуют.

# Сколько всего переменных с пропущенными значениями в данных и сколько пропущенных точек в каждой такой переменной?

```{r}
cleaned_data %>% 
  sapply(function(x) sum(is.na(x))) %>% 
  as.data.frame() %>% 
  rename('NA'='.')
```
Пропущенные значения отсутствуют.

# Описательные статистики

## Количественные переменные

1) Рассчитайте для всех количественных переменных для каждой группы (наличие или отсутствие сердечно-сосудистых заболеваний):

1.1) Количество значений;

1.2) Количество пропущенных значений;

1.3) Среднее;

1.4) Медиану;

1.5) Стандартное отклонение;

1.6) 25% квантиль и 75% квантиль;

1.7) Интерквартильный размах;

1.8) Минимум;

1.9) Максимум;

1.10) 95% ДИ для среднего - задание со звёздочкой.

Не нашел готового решения, которое бы удовлетворяло требованиям, поэтому написал свою функцию. Правда вывод - не в виде датафрейма.
```{r}
my_summarise_num <- function(x){
  Count = length(x)
  Missing = sum(is.na(x))
  Mean = mean(x, na.rm = TRUE)
  Median = median(x, na.rm = TRUE)
  StdDev = sd(x, na.rm = TRUE)
  Q1 = quantile(x, 0.25, na.rm = TRUE)
  Q3 = quantile(x, 0.75, na.rm = TRUE)
  IQR = Q3 - Q1
  Min = min(x, na.rm = TRUE)
  Max = max(x, na.rm = TRUE)
  CI_95_Lower = Mean - qt(0.975, Count - 1) * (StdDev / sqrt(Count))
  CI_95_Upper = Mean + qt(0.975, Count - 1) * (StdDev / sqrt(Count))
  data.frame(
    Count = Count,
    Missing = Missing,
    Mean = Mean,
    Median = Median,
    StdDev = StdDev,
    Q1 = Q1,
    Q3 = Q3,
    IQR = IQR,
    Min = Min,
    Max = Max,
    CI_95_Lower = CI_95_Lower,
    CI_95_Upper = CI_95_Upper
  )
}
cat("cardio = 0\n")
cleaned_data %>%
  filter(cardio==0) %>% 
  select_if(is.numeric) %>% 
  sapply(my_summarise_num)

cat("\n\ncardio = 1\n")
cleaned_data %>%
  filter(cardio==1) %>% 
  select_if(is.numeric) %>% 
  sapply(my_summarise_num)
```
IQR для давлений маленький, что впоследсвии отобразится на boxplot'ах. Для группы cardio - равен 0.

## Категориальные переменные

1) Рассчитайте для всех категориальных переменных для каждой группы (наличие или отсутствие сердечно-сосудистых заболеваний):

1.1) Абсолютное количество;

1.2) Относительное количество внутри группы;

1.3) 95% ДИ для доли внутри группы - задание со звёздочкой.

Так как уровни фактора отличаются, я вывод разбил на 3 группы:
1) gender, 
2) cholesterol, glucose, 
3) smoke, alcohol, active. 
Каждая группа разбита на 2 по наличию заболевания. Для всех групп посчитаны статистики. 
Возможно, хорошая была бы идея привести все категориальные признаки к единому виду (levels: 0, 1), чтобы удобно было интерпретировать(?).
```{r}
my_summarise_fac <- function(x, l) {
  x <- as.numeric(unlist(x))
  n <-  length(x)
  n_f <- sum(x==l)
  p <-  n_f / n
  se <- sqrt(p * (1 - p) / n)
  ci_lower <- p - 1.96 * se
  ci_upper <- p + 1.96 * se
  return(data.frame(
    Count_all = n,
    level = l,
    Count_factor = n_f,
    se = se,
    Proportion = p,
    Lower_CI = ci_lower,
    Upper_CI = ci_upper
  ))
}
cat('cardio==0\n')
cleaned_data %>% 
  filter(cardio==0) %>% 
  select(gender) %>% 
  sapply(my_summarise_fac, 1)
cat('\n')
cat('cardio==1\n')
cleaned_data %>% 
  filter(cardio==1) %>% 
  select(gender) %>% 
  sapply(my_summarise_fac, 1)
cat('\n')

cat('cardio==0\n')
cleaned_data %>% 
  filter(cardio==0) %>% 
  select(cholesterol, glucose) %>% 
  sapply(my_summarise_fac, 1)
cat('\n')
cat('cardio==1\n')
cleaned_data %>% 
  filter(cardio==1) %>% 
  select(cholesterol, glucose) %>% 
  sapply(my_summarise_fac, 1)
cat('\n')

cat('cardio==0\n')
cleaned_data %>% 
  filter(cardio==0) %>% 
  select(cholesterol, glucose) %>% 
  sapply(my_summarise_fac, 2)
cat('\n')
cat('cardio==1\n')
cleaned_data %>% 
  filter(cardio==1) %>% 
  select(cholesterol, glucose) %>% 
  sapply(my_summarise_fac, 2)
cat('\n')

cat('cardio==0\n')
cleaned_data %>% 
  filter(cardio==0) %>% 
  select(cholesterol, glucose) %>% 
  sapply(my_summarise_fac, 3)
cat('\n')
cat('cardio==1\n')
cleaned_data %>% 
  filter(cardio==1) %>% 
  select(cholesterol, glucose) %>% 
  sapply(my_summarise_fac, 3)
cat('\n')

cat('cardio==0\n')
cleaned_data %>% 
  filter(cardio==0) %>% 
  select(smoke, alcohol, active) %>% 
  sapply(my_summarise_fac, 1)
cat('\n')
cat('cardio==1\n')
cleaned_data %>% 
  filter(cardio==1) %>% 
  select(smoke, alcohol, active) %>% 
  sapply(my_summarise_fac, 1)
cat('\n')

```
# Визуализация

## Количественные переменные

1) Для каждой количественной переменной сделайте боксплоты по группам. Расположите их либо на отдельных рисунках, либо на одном, но читаемо;

2) Наложите на боксплоты beeplots - задание со звёздочкой.

3) Раскрасьте боксплоты с помощью библиотеки RColorBrewer.


```{r}
library(ggplot2)
library(RColorBrewer)
palette <- brewer.pal(3, "Set2")
cleaned_data %>% ggplot() +
  aes(cardio, age, fill=cardio) +
  geom_boxplot() +
  scale_fill_manual(values = palette) +
  theme_bw()
```

```{r}
library(ggplot2)
library(RColorBrewer)
palette <- brewer.pal(3, "Set2")
cleaned_data %>% ggplot() +
  aes(cardio, height, fill=cardio) +
  geom_boxplot() +
  scale_fill_manual(values = palette)+
  theme_bw()
```

```{r}
library(ggplot2)
library(RColorBrewer)
palette <- brewer.pal(3, "Set2")
cleaned_data %>% ggplot() +
  aes(cardio, weight, fill=cardio) +
  geom_boxplot() +
  scale_fill_manual(values = palette)+
  theme_bw()
```

```{r}
library(ggplot2)
library(RColorBrewer)
palette <- brewer.pal(3, "Set2")
cleaned_data %>% ggplot() +
  aes(cardio, `Arterial Pressure High`, fill=cardio) +
  geom_boxplot() +
  scale_fill_manual(values = palette)+
  theme_bw()
```

```{r}
library(ggplot2)
library(RColorBrewer)
palette <- brewer.pal(3, "Set2")
cleaned_data %>% ggplot() +
  aes(cardio, `Arterial Pressure Low`, fill=cardio) +
  geom_boxplot() +
  scale_fill_manual(values = palette)+
  theme_bw()
```

В давлениях группы cardio=0 много выбросов, из-за того, что IQR=0. Это следствие ненормального распределения (дискретность).

Далее beeswarm сделал только для 1000 наблюдений как пример. Если делать больше, то рой пчёл разлетается слишком сильно, перекрывая весь график (не разобрался, можно ли это сделать более эстетично)
```{r}
library(ggplot2)
library(RColorBrewer)
library(ggbeeswarm)
palette <- brewer.pal(3, "Set2")
cleaned_data %>% 
  head(1000) %>% 
  ggplot() +
  aes(cardio, age, fill = cardio) +
  geom_boxplot() +
  geom_beeswarm(color = "deepskyblue4", size = 1) +
  scale_fill_manual(values = palette) +
  theme_bw()
```
```{r}
library(ggplot2)
library(RColorBrewer)
library(ggbeeswarm)
palette <- brewer.pal(3, "Set2")
cleaned_data %>% 
  head(1000) %>% 
  ggplot() +
  aes(cardio, weight, fill=cardio) +
  geom_boxplot() +
  geom_beeswarm(color = "deepskyblue4", size = 1) +
  scale_fill_manual(values = palette)+
  theme_bw()
```

## Категориальные переменные

1) Сделайте подходящие визуализации категориальных переменных. Обоснуйте, почему выбрали именно этот тип.

```{r}
library(ggplot2)
palette <- brewer.pal(3, "Set2")
ggplot(cleaned_data, aes(x=cardio, fill=cardio)) +
  geom_bar() +
  facet_grid(glucose ~ gender) +
  xlab("gender") +
  ylab("glucose")+
  scale_fill_manual(values = palette)+
  theme_bw()
```

Видно, что соотношение больных меняется в худшую сторону с увеличением глюкозы, вне зависимости от пола.

```{r}
library(ggplot2)
palette <- brewer.pal(3, "Set2")
ggplot(cleaned_data, aes(x=cardio, fill=cardio)) +
  geom_bar() +
  facet_grid(cholesterol ~ gender) +
  xlab("gender") +
  ylab("cholesterol")+
  scale_fill_manual(values = palette)+
  theme_bw()
```

Видно, что холестерол тоже плохо влияет на соотношение больных и здоровых.

```{r}
library(ggplot2)
ggplot(cleaned_data, aes(x=cardio, fill=cardio)) +
  geom_bar() +
  facet_grid(smoke ~ gender) +
  xlab("gender") +
  ylab("alcohol")+
  scale_fill_manual(values = palette)+
  theme_bw()
```

Видно, что алкоголь отрицательно влияет на соотношение здоровых и больных, вне зависимости от пола.

```{r}
library(ggplot2)
ggplot(cleaned_data, aes(x=cardio, fill=cardio)) +
  geom_bar() +
  facet_grid(active ~ gender) +
  xlab("gender") +
  ylab("active")+
  scale_fill_manual(values = palette)+
  theme_bw()
```

Активность положительно влияет на соотношение здоровых и больных, для мужчин и женщин.

# Статистические оценки

## Проверка на нормальность

1) Оцените каждую переменную на соответствие нормальному распределению с помощью теста Шапиро-Уилка. Какие из переменных являются нормальными и как как вы это поняли?

```{r }
library(nortest)
normality.test  <- function(x){
  return(sapply(x[0:5000,], shapiro.test)["p.value",])
}
cleaned_data %>% 
  select_if(is.numeric) %>% 
  normality.test() %>% 
  as.data.frame()
```
Из-за ограничений функции, shapiro.test проведен для первых 5000 наблюдений. В результат говорит о том, что все величины имеют ненормальное распределение (p < 0.05). 

2) Постройте для каждой количественной переменной QQ-плот. Отличаются ли выводы от теста Шапиро-Уилка? Какой метод вы бы предпочли и почему?
```{r}
QQ <- function(x, label){
  qqnorm(x, main = c('Q-Q Plot for Normality\t',label))
  qqline(x)
}
QQ(cleaned_data$age, 'age')
QQ(cleaned_data$height, 'height')
QQ(cleaned_data$weight, 'weight')
QQ(cleaned_data$`Arterial Pressure High`, 'Arterial Pressure High')
QQ(cleaned_data$`Arterial Pressure Low`, 'Arterial Pressure Low')
```

"Arterial Pressure High" и "Arterial Pressure Low" имеют ступеньчатое распределение, в результате методики сбора данных.

3) Ниже напишите, какие ещё методы проверки на нормальность вы знаете и какие у них есть ограничения.

```{r }
library(nortest)
normality.test  <- function(x){
  return(sapply(x, ad.test)["p.value",])
}
cleaned_data %>% 
  select_if(is.numeric) %>% 
  normality.test() %>% 
  as.data.frame()
```
**Напишите текст здесь**
Anderson-Darling тест выбран из-за отсутствия ограничений и высокой мощности. Результат - распределение ненормальное.

## Сравнение групп

1) Сравните группы (переменная **cardio**) по каждой переменной (как количественной, так и категориальной). Для каждой переменной выберите нужный критерий и кратко обоснуйте его выбор в комментариях.

```{r}
t <- data.frame('age' = t.test(age ~ cardio, cleaned_data)$statistic,
     'height' = t.test(height ~ cardio, cleaned_data)$statistic,
     'weight' = t.test(height ~ cardio, cleaned_data)$statistic,
     'Arterial Pressure High' = t.test(`Arterial Pressure High` ~ cardio, cleaned_data)$statistic,
     'Arterial Pressure Low' = t.test(`Arterial Pressure Low` ~ cardio, cleaned_data)$statistic)
p <- data.frame('age' = t.test(age ~ cardio, cleaned_data)$p.value,
     'height' = t.test(height ~ cardio, cleaned_data)$p.value,
     'weight' = t.test(height ~ cardio, cleaned_data)$p.value,
     'Arterial Pressure High' = t.test(`Arterial Pressure High` ~ cardio, cleaned_data)$p.value,
     'Arterial Pressure Low' = t.test(`Arterial Pressure Low` ~ cardio, cleaned_data)$p.value)
rownames(p) <- "p"
rbind(t, p)
```
t-test показал статистически значимые различия в количественных переменных. Была идея сделать Манна-Уитни из-за нормального распределения (но я не сделал).


```{r}
tribble(
  ~Variable , ~statistic, ~p_value,
  'gender',  chisq.test(cleaned_data$gender, cleaned_data$cardio)$statistic, chisq.test(cleaned_data$gender, cleaned_data$cardio)$p.value,
  'cholesterol',  chisq.test(cleaned_data$cholesterol, cleaned_data$cardio)$statistic, chisq.test(cleaned_data$cholesterol, cleaned_data$cardio)$p.value,
  'glucose',  chisq.test(cleaned_data$glucose, cleaned_data$cardio)$statistic, chisq.test(cleaned_data$glucose, cleaned_data$cardio)$p.value,
  'smoke',  chisq.test(cleaned_data$smoke, cleaned_data$cardio)$statistic, chisq.test(cleaned_data$smoke, cleaned_data$cardio)$p.value,
  'alcohol',  chisq.test(cleaned_data$alcohol, cleaned_data$cardio)$statistic, chisq.test(cleaned_data$alcohol, cleaned_data$cardio)$p.value,
  'active',  chisq.test(cleaned_data$active, cleaned_data$cardio)$statistic, chisq.test(cleaned_data$active, cleaned_data$cardio)$p.value,
  )
```
chisq.test показал, что различия во всех факторных переменных, кроме пола, являются статистически значимыми.

# Далее идут **необязательные** дополнительные задания, которые могут принести вам дополнительные баллы в том числе в случае ошибок в предыдущих

## Корреляционный анализ

1) Создайте корреляционную матрицу с визуализацией и поправкой на множественные сравнения. Объясните, когда лучше использовать корреляционные матрицы и в чём минусы и плюсы корреляционных исследований.

```{r}
library(corrplot)
cleaned_data %>% 
  select_if(is.numeric) %>% 
  cor(method = "spearman") %>% 
  corrplot()
```

```{r}
library(psych)
cleaned_data %>% 
  select_if(is.numeric) %>%
  corr.test(adjust = "bonferroni", method = "spearman")
```
Так как распределение ненормальное, выбрал Спирмена с поправкой Бонферони. Несмотря на консервативность поправки  Бонферони, корреляции всех переменных, кроме 
"Arterial Pressure High" и "height", 
"Arterial Pressure Low" и "height",
оказались статистически значимыми.

Плюсы корреляционных исследований:
- Корреляция может помочь идентифицировать и измерить силу связи между переменными.
- Простота и интерпретируемость.
- Исследования корреляции могут помочь исключить из анализа переменные, которые слабо связаны с целевой переменной.

Минусы корреляционных исследований:
- Не означают причинно-следственная связь.
- Ограничение на линейную связь.
- Корреляция чувствительна к выбросам и аномалиям в данных.

## Моделирование

1) Постройте регрессионную модель для переменной **cardio**. Опишите процесс построения

```{r}
glm(cardio ~ ., cleaned_data[,-1], family = binomial) %>% 
  step() %>% 
  summary()
```

Функция step выбирает наилучшую модель логистической регрессии. В результате переменная gender была исключена из модели.
В результате все переменные, кроме glucose level 2, оказались статистически значимыми для предсказания заболевания.





